<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TinySTM: stm.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>stm.h File Reference</h1>
<p>STM functions.  
<a href="#_details">More...</a></p>

<p><a href="stm_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstm__tx__attr.html">stm_tx_attr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transaction attributes specified by the application.  <a href="structstm__tx__attr.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcbb6b78475bb3c13e4b6565ad2a2eb1"></a><!-- doxytag: member="stm.h::STM_VERSION" ref="adcbb6b78475bb3c13e4b6565ad2a2eb1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>STM_VERSION</b>&nbsp;&nbsp;&nbsp;&quot;1.0.0&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00c7d86533508752aabd69bc9e89c62f"></a><!-- doxytag: member="stm.h::STM_VERSION_NB" ref="a00c7d86533508752aabd69bc9e89c62f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>STM_VERSION_NB</b>&nbsp;&nbsp;&nbsp;100</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uintptr_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of a word (accessible atomically) on the target architecture.  <a href="#a571736ccf3baeb79b32e66efd03f2ff0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f969a019d50865dee2bac2269af19dc"></a><!-- doxytag: member="stm.h::stm_tx_attr_t" ref="a5f969a019d50865dee2bac2269af19dc" args="" -->
typedef struct <a class="el" href="structstm__tx__attr.html">stm_tx_attr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a5f969a019d50865dee2bac2269af19dc">stm_tx_attr_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transaction attributes specified by the application. <br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba7b61a76a11fbf84128a391a9b0cef327">STM_ABORT_EXPLICIT</a> =  (1 &lt;&lt; 4), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba75d0311e7a4ddd3064164e4642d0fa95">STM_ABORT_IMPLICIT</a> =  (1 &lt;&lt; 5), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba46eaf37a2b51b4db497304a3e8869973">STM_ABORT_RR_CONFLICT</a> =  (1 &lt;&lt; 5) | (0x01 &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55baa0ab09921c0090164a7d6aa2538cac17">STM_ABORT_RW_CONFLICT</a> =  (1 &lt;&lt; 5) | (0x02 &lt;&lt; 8), 
<br/>
&nbsp;&nbsp;<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba4e7abf037faa563495f6fa5da509219c">STM_ABORT_WR_CONFLICT</a> =  (1 &lt;&lt; 5) | (0x03 &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba4d97b7b8272d8d7683ab5a0ffe9c25e7">STM_ABORT_WW_CONFLICT</a> =  (1 &lt;&lt; 5) | (0x04 &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55baa705d4540e95c9b214d2dbbebeb7dbe3">STM_ABORT_VAL_READ</a> =  (1 &lt;&lt; 5) | (0x05 &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba30a4997234b15d65d38e27db17f3e93c">STM_ABORT_VAL_WRITE</a> =  (1 &lt;&lt; 5) | (0x06 &lt;&lt; 8), 
<br/>
&nbsp;&nbsp;<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55badb805d9ecf362fe018eeacb14bc7c73e">STM_ABORT_VALIDATE</a> =  (1 &lt;&lt; 5) | (0x07 &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba3004393c04fbcdc9e1d03456465801c4">STM_ABORT_RO_WRITE</a> =  (1 &lt;&lt; 5) | (0x08 &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba8f6e471602d10189a79ca90ffd4d11e2">STM_ABORT_IRREVOCABLE</a> =  (1 &lt;&lt; 5) | (0x09 &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55baeb8c86645eef38a461e9ff85c3807c3e">STM_ABORT_KILLED</a> =  (1 &lt;&lt; 5) | (0x0A &lt;&lt; 8), 
<br/>
&nbsp;&nbsp;<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba840c7cb44183d525c2a308071f486670">STM_ABORT_SIGNAL</a> =  (1 &lt;&lt; 5) | (0x0B &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba886ebf1c55e78174f2734cf34e699608">STM_ABORT_OTHER</a> =  (1 &lt;&lt; 5) | (0x0F &lt;&lt; 8)
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Reason for aborting (returned by sigsetjmp() upon transaction restart). </p>
 <a href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55b">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a9dfcb42f2a39f6b806454a255ad50e4f">stm_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the STM library.  <a href="#a9dfcb42f2a39f6b806454a255ad50e4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a23b7b67a612502b082a6e324a5b4218d">stm_exit</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clean up the STM library.  <a href="#a23b7b67a612502b082a6e324a5b4218d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a9489359650ffb7ea4d2e1431491b27ee">stm_init_thread</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a transactional thread.  <a href="#a9489359650ffb7ea4d2e1431491b27ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ae361e754dc0aa0b54ed4e5b3ba15f06b">stm_exit_thread</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clean up a transactional thread.  <a href="#ae361e754dc0aa0b54ed4e5b3ba15f06b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sigjmp_buf *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a4745d0a31ae146d46af8c6e471120833">stm_start</a> (<a class="el" href="structstm__tx__attr.html">stm_tx_attr_t</a> *attr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start a transaction.  <a href="#a4745d0a31ae146d46af8c6e471120833"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a2307b5aa456731bcd92a2dc481258f89">stm_commit</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to commit a transaction.  <a href="#a2307b5aa456731bcd92a2dc481258f89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a689d0e2f43d0c823699cd8255ad7bd8d">stm_abort</a> (int abort_reason)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Explicitly abort a transaction.  <a href="#a689d0e2f43d0c823699cd8255ad7bd8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a473026557b3911a3af8b1b2fc4cc426c">stm_load</a> (volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transactional load.  <a href="#a473026557b3911a3af8b1b2fc4cc426c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a5a822c0df0ff5938016674955e7ae99e">stm_store</a> (volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transactional store.  <a href="#a5a822c0df0ff5938016674955e7ae99e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a77218104875612813d7f2791ac343cf6">stm_store2</a> (volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> value, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transactional store.  <a href="#a77218104875612813d7f2791ac343cf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ae2cafb5bccc1c71ceed7cd3f0b6c5fc6">stm_active</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current transaction is still active.  <a href="#ae2cafb5bccc1c71ceed7cd3f0b6c5fc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a017b9b17faf18324ccd22c4369c86a53">stm_aborted</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current transaction has aborted.  <a href="#a017b9b17faf18324ccd22c4369c86a53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a25e4a94703f6c0de018681f7723c8baa">stm_irrevocable</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current transaction is still active and in irrevocable state.  <a href="#a25e4a94703f6c0de018681f7723c8baa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sigjmp_buf *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#aae58c1c5e363ae7e2ddc22f1208c7256">stm_get_env</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the environment used by the current thread to jump back upon abort.  <a href="#aae58c1c5e363ae7e2ddc22f1208c7256"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstm__tx__attr.html">stm_tx_attr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ad2d9401a5819a26dc4f4992a3d2cb529">stm_get_attributes</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get attributes associated with the current transactions, if any.  <a href="#ad2d9401a5819a26dc4f4992a3d2cb529"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#aaa4e7819e2e3eebec0406555a2ea4502">stm_get_stats</a> (const char *name, void *val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get various statistics about the current thread/transaction.  <a href="#aaa4e7819e2e3eebec0406555a2ea4502"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#aac7f1c4dd5f948f23a2f4df0a7d530d6">stm_get_parameter</a> (const char *name, void *val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get various parameters of the STM library.  <a href="#aac7f1c4dd5f948f23a2f4df0a7d530d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#abca06bb60ae936118c769f6fdd41530c">stm_set_parameter</a> (const char *name, void *val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set various parameters of the STM library.  <a href="#abca06bb60ae936118c769f6fdd41530c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#afbb66f0208d71702f6dfb304b9628594">stm_create_specific</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a key to associate application-specific data to the current thread/transaction.  <a href="#afbb66f0208d71702f6dfb304b9628594"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ac8b66dbadfd62e541409823d1b80aba7">stm_get_specific</a> (int key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get application-specific data associated to the current thread/transaction and a given key.  <a href="#ac8b66dbadfd62e541409823d1b80aba7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#acf336ae279fd83cf1195bd76aea01df7">stm_set_specific</a> (int key, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set application-specific data associated to the current thread/transaction and a given key.  <a href="#acf336ae279fd83cf1195bd76aea01df7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a54fcf0b2074258b824b60c395083ed4d">stm_register</a> (void(*on_thread_init)(void *arg), void(*on_thread_exit)(void *arg), void(*on_start)(void *arg), void(*on_commit)(void *arg), void(*on_abort)(void *arg), void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register application-specific callbacks that are triggered each time particular events occur.  <a href="#a54fcf0b2074258b824b60c395083ed4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ac932e2cd9b2b1621326d281329362bfc">stm_unit_load</a> (volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *timestamp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transaction-safe load.  <a href="#ac932e2cd9b2b1621326d281329362bfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#aec9492eba41d0df151c30fc559a14957">stm_unit_store</a> (volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> value, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *timestamp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transaction-safe store.  <a href="#aec9492eba41d0df151c30fc559a14957"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a328faa38ec6bf579ba6fd166765a7527">stm_unit_store2</a> (volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> value, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> mask, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *timestamp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transaction-safe store.  <a href="#a328faa38ec6bf579ba6fd166765a7527"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a9ca153a890bb4daff693a21897834301">stm_set_extension</a> (int enable, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *timestamp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable snapshot extensions for the current transaction, and optionally set an upper bound for the snapshot.  <a href="#a9ca153a890bb4daff693a21897834301"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a30979ab656135fe712adffcbeed80e15">stm_get_clock</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the current value of the global clock (used for timestamps).  <a href="#a30979ab656135fe712adffcbeed80e15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ad4fb1a17427e6ad727df28074a646575">stm_set_irrevocable</a> (int serial)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enter irrevokable mode for the current transaction.  <a href="#ad4fb1a17427e6ad727df28074a646575"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>STM functions. </p>
<p>This library contains the core functions for programming with STM. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Pascal Felber &lt;<a href="mailto:pascal.felber@unine.ch">pascal.felber@unine.ch</a>&gt; </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2007-2009 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a571736ccf3baeb79b32e66efd03f2ff0"></a><!-- doxytag: member="stm.h::stm_word_t" ref="a571736ccf3baeb79b32e66efd03f2ff0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uintptr_t <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size of a word (accessible atomically) on the target architecture. </p>
<p>The library supports 32-bit and 64-bit architectures. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55b"></a><!-- doxytag: member="stm.h::@0" ref="a06fc87d81c62e9abb8790b6e5713c55b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reason for aborting (returned by sigsetjmp() upon transaction restart). </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba7b61a76a11fbf84128a391a9b0cef327"></a><!-- doxytag: member="STM_ABORT_EXPLICIT" ref="a06fc87d81c62e9abb8790b6e5713c55ba7b61a76a11fbf84128a391a9b0cef327" args="" -->STM_ABORT_EXPLICIT</em>&nbsp;</td><td>
<p>Abort due to explicit call from the programmer (no retry). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba75d0311e7a4ddd3064164e4642d0fa95"></a><!-- doxytag: member="STM_ABORT_IMPLICIT" ref="a06fc87d81c62e9abb8790b6e5713c55ba75d0311e7a4ddd3064164e4642d0fa95" args="" -->STM_ABORT_IMPLICIT</em>&nbsp;</td><td>
<p>Implicit abort (high order bits indicate more detailed reason). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba46eaf37a2b51b4db497304a3e8869973"></a><!-- doxytag: member="STM_ABORT_RR_CONFLICT" ref="a06fc87d81c62e9abb8790b6e5713c55ba46eaf37a2b51b4db497304a3e8869973" args="" -->STM_ABORT_RR_CONFLICT</em>&nbsp;</td><td>
<p>Abort upon reading a memory location being read by another transaction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55baa0ab09921c0090164a7d6aa2538cac17"></a><!-- doxytag: member="STM_ABORT_RW_CONFLICT" ref="a06fc87d81c62e9abb8790b6e5713c55baa0ab09921c0090164a7d6aa2538cac17" args="" -->STM_ABORT_RW_CONFLICT</em>&nbsp;</td><td>
<p>Abort upon writing a memory location being read by another transaction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba4e7abf037faa563495f6fa5da509219c"></a><!-- doxytag: member="STM_ABORT_WR_CONFLICT" ref="a06fc87d81c62e9abb8790b6e5713c55ba4e7abf037faa563495f6fa5da509219c" args="" -->STM_ABORT_WR_CONFLICT</em>&nbsp;</td><td>
<p>Abort upon reading a memory location being written by another transaction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba4d97b7b8272d8d7683ab5a0ffe9c25e7"></a><!-- doxytag: member="STM_ABORT_WW_CONFLICT" ref="a06fc87d81c62e9abb8790b6e5713c55ba4d97b7b8272d8d7683ab5a0ffe9c25e7" args="" -->STM_ABORT_WW_CONFLICT</em>&nbsp;</td><td>
<p>Abort upon writing a memory location being written by another transaction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55baa705d4540e95c9b214d2dbbebeb7dbe3"></a><!-- doxytag: member="STM_ABORT_VAL_READ" ref="a06fc87d81c62e9abb8790b6e5713c55baa705d4540e95c9b214d2dbbebeb7dbe3" args="" -->STM_ABORT_VAL_READ</em>&nbsp;</td><td>
<p>Abort upon read due to failed validation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba30a4997234b15d65d38e27db17f3e93c"></a><!-- doxytag: member="STM_ABORT_VAL_WRITE" ref="a06fc87d81c62e9abb8790b6e5713c55ba30a4997234b15d65d38e27db17f3e93c" args="" -->STM_ABORT_VAL_WRITE</em>&nbsp;</td><td>
<p>Abort upon write due to failed validation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55badb805d9ecf362fe018eeacb14bc7c73e"></a><!-- doxytag: member="STM_ABORT_VALIDATE" ref="a06fc87d81c62e9abb8790b6e5713c55badb805d9ecf362fe018eeacb14bc7c73e" args="" -->STM_ABORT_VALIDATE</em>&nbsp;</td><td>
<p>Abort upon commit due to failed validation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba3004393c04fbcdc9e1d03456465801c4"></a><!-- doxytag: member="STM_ABORT_RO_WRITE" ref="a06fc87d81c62e9abb8790b6e5713c55ba3004393c04fbcdc9e1d03456465801c4" args="" -->STM_ABORT_RO_WRITE</em>&nbsp;</td><td>
<p>Abort upon write from a transaction declared as read-only. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba8f6e471602d10189a79ca90ffd4d11e2"></a><!-- doxytag: member="STM_ABORT_IRREVOCABLE" ref="a06fc87d81c62e9abb8790b6e5713c55ba8f6e471602d10189a79ca90ffd4d11e2" args="" -->STM_ABORT_IRREVOCABLE</em>&nbsp;</td><td>
<p>Abort upon deferring to an irrevocable transaction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55baeb8c86645eef38a461e9ff85c3807c3e"></a><!-- doxytag: member="STM_ABORT_KILLED" ref="a06fc87d81c62e9abb8790b6e5713c55baeb8c86645eef38a461e9ff85c3807c3e" args="" -->STM_ABORT_KILLED</em>&nbsp;</td><td>
<p>Abort due to being killed by another transaction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba840c7cb44183d525c2a308071f486670"></a><!-- doxytag: member="STM_ABORT_SIGNAL" ref="a06fc87d81c62e9abb8790b6e5713c55ba840c7cb44183d525c2a308071f486670" args="" -->STM_ABORT_SIGNAL</em>&nbsp;</td><td>
<p>Abort due to receiving a signal. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba886ebf1c55e78174f2734cf34e699608"></a><!-- doxytag: member="STM_ABORT_OTHER" ref="a06fc87d81c62e9abb8790b6e5713c55ba886ebf1c55e78174f2734cf34e699608" args="" -->STM_ABORT_OTHER</em>&nbsp;</td><td>
<p>Abort due to other reasons (internal to the protocol). </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a689d0e2f43d0c823699cd8255ad7bd8d"></a><!-- doxytag: member="stm.h::stm_abort" ref="a689d0e2f43d0c823699cd8255ad7bd8d" args="(int abort_reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_abort </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>abort_reason</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Explicitly abort a transaction. </p>
<p>Execution continues at the point where sigsetjmp() has been called after starting the outermost transaction (unless the attributes indicate that the transaction should not retry). </p>

</div>
</div>
<a class="anchor" id="a017b9b17faf18324ccd22c4369c86a53"></a><!-- doxytag: member="stm.h::stm_aborted" ref="a017b9b17faf18324ccd22c4369c86a53" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_aborted </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the current transaction has aborted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True (non-zero) if the transaction has aborted, false (zero) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2cafb5bccc1c71ceed7cd3f0b6c5fc6"></a><!-- doxytag: member="stm.h::stm_active" ref="ae2cafb5bccc1c71ceed7cd3f0b6c5fc6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_active </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the current transaction is still active. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True (non-zero) if the transaction is active, false (zero) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2307b5aa456731bcd92a2dc481258f89"></a><!-- doxytag: member="stm.h::stm_commit" ref="a2307b5aa456731bcd92a2dc481258f89" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_commit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to commit a transaction. </p>
<p>If successful, the function returns 1. Otherwise, execution continues at the point where sigsetjmp() has been called after starting the outermost transaction (unless the attributes indicate that the transaction should not retry).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 upon success, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afbb66f0208d71702f6dfb304b9628594"></a><!-- doxytag: member="stm.h::stm_create_specific" ref="afbb66f0208d71702f6dfb304b9628594" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_create_specific </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a key to associate application-specific data to the current thread/transaction. </p>
<p>This mechanism can be combined with callbacks to write modules.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new key. </dd></dl>

</div>
</div>
<a class="anchor" id="a23b7b67a612502b082a6e324a5b4218d"></a><!-- doxytag: member="stm.h::stm_exit" ref="a23b7b67a612502b082a6e324a5b4218d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_exit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clean up the STM library. </p>
<p>This function must be called once, from the main thread, after all transactional threads have completed. </p>

</div>
</div>
<a class="anchor" id="ae361e754dc0aa0b54ed4e5b3ba15f06b"></a><!-- doxytag: member="stm.h::stm_exit_thread" ref="ae361e754dc0aa0b54ed4e5b3ba15f06b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_exit_thread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clean up a transactional thread. </p>
<p>This function must be called once from each thread that performs transactional operations, upon exit. </p>

</div>
</div>
<a class="anchor" id="ad2d9401a5819a26dc4f4992a3d2cb529"></a><!-- doxytag: member="stm.h::stm_get_attributes" ref="ad2d9401a5819a26dc4f4992a3d2cb529" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstm__tx__attr.html">stm_tx_attr_t</a>* stm_get_attributes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get attributes associated with the current transactions, if any. </p>
<p>These attributes were passed as parameters when starting the transaction.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Attributes associated with the current transaction, or NULL if no attributes were specified when starting the transaction. </dd></dl>

</div>
</div>
<a class="anchor" id="a30979ab656135fe712adffcbeed80e15"></a><!-- doxytag: member="stm.h::stm_get_clock" ref="a30979ab656135fe712adffcbeed80e15" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> stm_get_clock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the current value of the global clock (used for timestamps). </p>
<p>This function is useful when programming with unit loads and stores.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of the global clock. </dd></dl>

</div>
</div>
<a class="anchor" id="aae58c1c5e363ae7e2ddc22f1208c7256"></a><!-- doxytag: member="stm.h::stm_get_env" ref="aae58c1c5e363ae7e2ddc22f1208c7256" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigjmp_buf* stm_get_env </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the environment used by the current thread to jump back upon abort. </p>
<p>This environment should be used when calling sigsetjmp() before starting the transaction and passed as parameter to <a class="el" href="stm_8h.html#a4745d0a31ae146d46af8c6e471120833" title="Start a transaction.">stm_start()</a>. If the current thread is already executing a transaction, i.e., the new transaction will be nested, the function returns NULL and one should not call sigsetjmp().</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The environment to use for saving the stack context, or NULL if the transaction is nested. </dd></dl>

</div>
</div>
<a class="anchor" id="aac7f1c4dd5f948f23a2f4df0a7d530d6"></a><!-- doxytag: member="stm.h::stm_get_parameter" ref="aac7f1c4dd5f948f23a2f4df0a7d530d6" args="(const char *name, void *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_get_parameter </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get various parameters of the STM library. </p>
<p>See the source code (stm.c) for a list of supported parameters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the parameter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Pointer to the variable that should hold the value of the parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 upon success, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8b66dbadfd62e541409823d1b80aba7"></a><!-- doxytag: member="stm.h::stm_get_specific" ref="ac8b66dbadfd62e541409823d1b80aba7" args="(int key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* stm_get_specific </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get application-specific data associated to the current thread/transaction and a given key. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Key designating the data to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Data stored under the given key. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa4e7819e2e3eebec0406555a2ea4502"></a><!-- doxytag: member="stm.h::stm_get_stats" ref="aaa4e7819e2e3eebec0406555a2ea4502" args="(const char *name, void *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_get_stats </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get various statistics about the current thread/transaction. </p>
<p>See the source code (stm.c) for a list of supported statistics.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the statistics. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Pointer to the variable that should hold the value of the statistics. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 upon success, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9dfcb42f2a39f6b806454a255ad50e4f"></a><!-- doxytag: member="stm.h::stm_init" ref="a9dfcb42f2a39f6b806454a255ad50e4f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the STM library. </p>
<p>This function must be called once, from the main thread, before any access to the other functions of the library. </p>

</div>
</div>
<a class="anchor" id="a9489359650ffb7ea4d2e1431491b27ee"></a><!-- doxytag: member="stm.h::stm_init_thread" ref="a9489359650ffb7ea4d2e1431491b27ee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_init_thread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a transactional thread. </p>
<p>This function must be called once from each thread that performs transactional operations, before the thread calls any other functions of the library. </p>

</div>
</div>
<a class="anchor" id="a25e4a94703f6c0de018681f7723c8baa"></a><!-- doxytag: member="stm.h::stm_irrevocable" ref="a25e4a94703f6c0de018681f7723c8baa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_irrevocable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the current transaction is still active and in irrevocable state. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True (non-zero) if the transaction is active and irrevocable, false (zero) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a473026557b3911a3af8b1b2fc4cc426c"></a><!-- doxytag: member="stm.h::stm_load" ref="a473026557b3911a3af8b1b2fc4cc426c" args="(volatile stm_word_t *addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> stm_load </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transactional load. </p>
<p>Read the specified memory location in the context of the current transaction and return its value. Upon conflict, the transaction may abort while reading the memory location. Note that the value returned is consistent with respect to previous reads from the same transaction.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address of the memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value read from the specified address. </dd></dl>

</div>
</div>
<a class="anchor" id="a54fcf0b2074258b824b60c395083ed4d"></a><!-- doxytag: member="stm.h::stm_register" ref="a54fcf0b2074258b824b60c395083ed4d" args="(void(*on_thread_init)(void *arg), void(*on_thread_exit)(void *arg), void(*on_start)(void *arg), void(*on_commit)(void *arg), void(*on_abort)(void *arg), void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_register </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *arg)&nbsp;</td>
          <td class="paramname"> <em>on_thread_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&nbsp;</td>
          <td class="paramname"> <em>on_thread_exit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&nbsp;</td>
          <td class="paramname"> <em>on_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&nbsp;</td>
          <td class="paramname"> <em>on_commit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&nbsp;</td>
          <td class="paramname"> <em>on_abort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register application-specific callbacks that are triggered each time particular events occur. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>on_thread_init</em>&nbsp;</td><td>Function called upon initialization of a transactional thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_thread_exit</em>&nbsp;</td><td>Function called upon cleanup of a transactional thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_start</em>&nbsp;</td><td>Function called upon start of a transaction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_commit</em>&nbsp;</td><td>Function called upon successful transaction commit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_abort</em>&nbsp;</td><td>Function called upon transaction abort. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Parameter to be passed to the callback functions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the callbacks have been successfully registered, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ca153a890bb4daff693a21897834301"></a><!-- doxytag: member="stm.h::stm_set_extension" ref="a9ca153a890bb4daff693a21897834301" args="(int enable, stm_word_t *timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_set_extension </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable snapshot extensions for the current transaction, and optionally set an upper bound for the snapshot. </p>
<p>This function is useful for implementing efficient algorithms with unit loads and stores while preserving compatibility with with regular transactions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>True (non-zero) to enable snapshot extensions, false (zero) to disable them. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>If non-null and the timestamp in the referenced variable is smaller than the current upper bound of the snapshot, update the upper bound to the value of the referenced variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4fb1a17427e6ad727df28074a646575"></a><!-- doxytag: member="stm.h::stm_set_irrevocable" ref="ad4fb1a17427e6ad727df28074a646575" args="(int serial)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_set_irrevocable </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>serial</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enter irrevokable mode for the current transaction. </p>
<p>If successful, the function returns 1. Otherwise, it aborts and execution continues at the point where sigsetjmp() has been called after starting the outermost transaction (unless the attributes indicate that the transaction should not retry).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>True (non-zero) for serial-irrevocable mode (no transaction can execute concurrently), false for parallel-irrevocable mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 upon success, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abca06bb60ae936118c769f6fdd41530c"></a><!-- doxytag: member="stm.h::stm_set_parameter" ref="abca06bb60ae936118c769f6fdd41530c" args="(const char *name, void *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_set_parameter </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set various parameters of the STM library. </p>
<p>See the source code (stm.c) for a list of supported parameters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the parameter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Pointer to a variable that holds the new value of the parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 upon success, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acf336ae279fd83cf1195bd76aea01df7"></a><!-- doxytag: member="stm.h::stm_set_specific" ref="acf336ae279fd83cf1195bd76aea01df7" args="(int key, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_set_specific </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set application-specific data associated to the current thread/transaction and a given key. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Key designating the data to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Data to store under the given key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4745d0a31ae146d46af8c6e471120833"></a><!-- doxytag: member="stm.h::stm_start" ref="a4745d0a31ae146d46af8c6e471120833" args="(stm_tx_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigjmp_buf* stm_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstm__tx__attr.html">stm_tx_attr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start a transaction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Specifies optional attributes associated to the transaction. If null, the transaction uses default attributes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Environment (stack context) to be used to jump back upon abort. It is the responsibility of the application to call sigsetjmp() immediately after starting the transaction. If the transaction is nested, the function returns NULL and one should not call sigsetjmp() as an abort will restart the top-level transaction (flat nesting). </dd></dl>

</div>
</div>
<a class="anchor" id="a5a822c0df0ff5938016674955e7ae99e"></a><!-- doxytag: member="stm.h::stm_store" ref="a5a822c0df0ff5938016674955e7ae99e" args="(volatile stm_word_t *addr, stm_word_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_store </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transactional store. </p>
<p>Write a word-sized value to the specified memory location in the context of the current transaction. Upon conflict, the transaction may abort while writing to the memory location.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address of the memory location. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77218104875612813d7f2791ac343cf6"></a><!-- doxytag: member="stm.h::stm_store2" ref="a77218104875612813d7f2791ac343cf6" args="(volatile stm_word_t *addr, stm_word_t value, stm_word_t mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_store2 </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transactional store. </p>
<p>Write a value to the specified memory location in the context of the current transaction. The value may be smaller than a word on the target architecture, in which case a mask is used to indicate the bits of the words that must be updated. Upon conflict, the transaction may abort while writing to the memory location.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address of the memory location. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>Mask specifying the bits to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac932e2cd9b2b1621326d281329362bfc"></a><!-- doxytag: member="stm.h::stm_unit_load" ref="ac932e2cd9b2b1621326d281329362bfc" args="(volatile stm_word_t *addr, stm_word_t *timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> stm_unit_load </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transaction-safe load. </p>
<p>Read the specified memory location outside of the context of any transaction and return its value. The operation behaves as if executed in the context of a dedicated transaction (i.e., it executes atomically and in isolation) that never aborts, but may get delayed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address of the memory location.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>If non-null, the referenced variable is updated to hold the timestamp of the memory location being read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value read from the specified address. </dd></dl>

</div>
</div>
<a class="anchor" id="aec9492eba41d0df151c30fc559a14957"></a><!-- doxytag: member="stm.h::stm_unit_store" ref="aec9492eba41d0df151c30fc559a14957" args="(volatile stm_word_t *addr, stm_word_t value, stm_word_t *timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_unit_store </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transaction-safe store. </p>
<p>Write a word-sized value to the specified memory location outside of the context of any transaction. The operation behaves as if executed in the context of a dedicated transaction (i.e., it executes atomically and in isolation) that never aborts, but may get delayed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address of the memory location. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>If non-null and the timestamp in the referenced variable is smaller than that of the memory location being written, no data is actually written and the variable is updated to hold the more recent timestamp. If non-null and the timestamp in the referenced variable is not smaller than that of the memory location being written, the memory location is written and the variable is updated to hold the new timestamp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if value has been written, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a328faa38ec6bf579ba6fd166765a7527"></a><!-- doxytag: member="stm.h::stm_unit_store2" ref="a328faa38ec6bf579ba6fd166765a7527" args="(volatile stm_word_t *addr, stm_word_t value, stm_word_t mask, stm_word_t *timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_unit_store2 </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transaction-safe store. </p>
<p>Write a value to the specified memory location outside of the context of any transaction. The value may be smaller than a word on the target architecture, in which case a mask is used to indicate the bits of the words that must be updated. The operation behaves as if executed in the context of a dedicated transaction (i.e., it executes atomically and in isolation) that never aborts, but may get delayed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address of the memory location. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>Mask specifying the bits to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>If non-null and the timestamp in the referenced variable is smaller than that of the memory location being written, no data is actually written and the variable is updated to hold the more recent timestamp. If non-null and the timestamp in the referenced variable is not smaller than that of the memory location being written, the memory location is written and the variable is updated to hold the new timestamp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if value has been written, 0 otherwise. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Feb 22 15:49:59 2010 for TinySTM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
